// Generated by CoffeeScript 1.12.7
(function() {
  var Assets, CSON, Clean, CompileAll, CompileIncremental, Configure, Launch, Link, Mustache, Prebuild, Rebuild, Start, cache, changed, config, cson, exec, fs, glob, gulp, gulpcson, merge, mustache, newer, path, print, remember, rename, repl, run, spawn, stream, watch, watcher, yargs;

  path = require('path');

  fs = require('fs');

  exec = (require('child_process')).exec;

  spawn = (require('child_process')).spawn;

  gulp = require('gulp');

  rename = require("gulp-rename");

  mustache = require("gulp-mustache");

  watch = require('gulp-watch');

  gulpcson = require('gulp-cson');

  print = require('gulp-print');

  run = require('gulp-run');

  repl = require('gulp-repl');

  changed = require('gulp-changed');

  newer = require('gulp-newer');

  cache = require('gulp-cached');

  remember = require('gulp-remember');

  yargs = require('yargs').argv;

  cson = require('cson');

  glob = require('glob');

  merge = require('deepmerge');

  stream = require('stream');

  config = new (require('./config.js'))();

  Start = function(done) {
    gulp.repl = repl.start(gulp);
    return done();
  };

  Configure = function(done) {
    var buffer, rs;
    if (yargs.config === void 0) {
      yargs.config = 'example.cson';
    }
    console.log('Configuring from file: ' + yargs.config);
    buffer = '';
    rs = fs.createReadStream(yargs.config, {
      flags: 'r',
      encoding: 'utf8'
    });
    rs.on('error', function(err) {
      return console.log('error: ' + err);
    });
    rs.on('data', function(chunk) {
      return buffer += chunk;
    });
    return rs.on('end', function() {
      var obj, target;
      obj = cson.parse(buffer);
      config = merge(config, obj);
      target = void 0;
      switch (config.platform) {
        case 'linux':
          target = config.target.linux;
          break;
        case 'darwin':
          target = config.target.darwin;
          break;
        default:
          console.log("platform " + config, platform(+"not supported by build script!"));
      }
      config.project = merge(config.project, target);
      console.log('Configured for platform: ' + config.platform);
      return done();
    });
  };

  Clean = function(done) {
    fs.unlink(path.resolve(config.dirOutput, config.project.outputExecutableName), function() {
      return {};
    });
    if (config.platform === 'darwin') {
      return fs.stat(path.resolve(config.dirOutput, config.project.outputExecutableName + '.dSYM'), function(err, stats) {
        return fs.unlink(path.resolve(config.dirOutput, config.project.outputExecutableName + '.dSYM'), function(err) {
          return done();
        });
      });
    } else {
      return done();
    }
  };

  Assets = function(done) {
    return gulp.src(config.project.assetGlob, {
      cwd: path.resolve(config.dirAsset),
      ignoreInitial: false
    }).pipe(print((function(_this) {
      return function(filepath) {
        return 'Asset copied: ' + filepath;
      };
    })(this))).pipe(gulp.dest(config.dirOutput)).on('finish', function() {
      return done();
    });
  };

  CSON = function(done) {
    return gulp.src('**/*.cson', {
      cwd: path.resolve(config.dirAsset),
      ignoreInitial: false
    }).pipe(gulpcson()).pipe(print((function(_this) {
      return function(filepath) {
        return 'CSON=>JSON: ' + filepath;
      };
    })(this))).pipe(gulp.dest(config.dirOutput)).on('finish', function() {
      return done();
    });
  };

  Mustache = function(done) {
    return gulp.src(config.mustache.sourceGlob, {
      cwd: path.resolve(config.dirSource)
    }).pipe(mustache(config.mustache.context)).pipe(rename(config.mustache.rename)).pipe(print((function(_this) {
      return function(filepath) {
        return 'Mustaching: ' + filepath;
      };
    })(this))).pipe(gulp.dest(config.dirGeneratedSourceOutput)).on('finish', function() {
      return done();
    });
  };

  watcher = function(done) {
    gulp.watch(config.mustache.sourceGlob, Mustache);
    gulp.watch('**/*.cson', CSON);
    return gulp.watch(config.project.assetGlob, Mustache);
  };

  CompileAll = function(done) {
    var command, comp, count, externalSourceFiles, f, i, len, results, sourceFiles, total;
    if (fs.existsSync(config.dirObj === false)) {
      fs.mkdirSync(config.dirObj);
    }
    sourceFiles = glob.sync(path.resolve(config.dirSource, config.project.sourceGlob));
    externalSourceFiles = glob.sync(path.resolve(config.dirExternal, 'src', config.project.sourceGlob));
    sourceFiles.push(externalSourceFiles.join(' '));
    comp = [];
    comp.push(config.project.compilerDefines.join(' '));
    comp.push(config.includeDirectories.join(' '));
    total = sourceFiles.length;
    count = total;
    results = [];
    for (i = 0, len = sourceFiles.length; i < len; i++) {
      f = sourceFiles[i];
      command = 'clang++ -g -c -o ' + path.resolve(config.dirObj, path.basename(f, '.cpp') + '.o') + ' ' + f + ' ' + comp.join(' ');
      results.push(exec(command, function(err, stdout, stderr) {
        if (err) {
          console.error(err);
          return;
        }
        console.log(stdout);
        count--;
        console.log(parseInt(100 * (1 - count / total)).toString() + '%');
        if (count === 0) {
          return done();
        }
      }));
    }
    return results;
  };

  CompileIncremental = function(done) {
    var command, comp, sourceGlobs;
    comp = [];
    comp.push(config.project.compilerDefines.join(' '));
    comp.push(config.includeDirectories.join(' '));
    command = 'clang++ -x c++ -g -c - -o - ' + comp.join(' ');
    console.log(command);
    sourceGlobs = [path.resolve(config.dirSource, config.project.sourceGlob), path.resolve(config.dirExternal, 'src', config.project.sourceGlob)];
    console.log(sourceGlobs);
    return gulp.src(sourceGlobs).pipe(run(command, {
      silent: true
    })).pipe(print(function(filepath) {
      return 'compiled: ' + filepath;
    })).pipe(rename({
      dirname: '',
      extname: '.o'
    })).pipe(gulp.dest(config.dirObj));
  };

  Link = function(done) {
    var link, linkCommand, linkerArgs, objectFiles;
    link = [];
    linkerArgs = config.project.linkerArgs;
    linkerArgs.push(config.linkerDirectories);
    link.push('-Wl,' + linkerArgs.join(','));
    if (config.platform === 'darwin') {
      link.push(frameworks.join(' '));
    }
    objectFiles = glob.sync(config.dirObj + '/**/*.o');
    linkCommand = ['clang++ -g', objectFiles.join(' '), link.join(' '), '-o', path.resolve(config.dirOutput, config.project.outputExecutableName)].join(' ');
    console.log(linkCommand);
    return exec(linkCommand, function(err, stdout, stderr) {
      console.log(stdout);
      console.log(stderr);
      if (err) {
        console.error('LINK ERROR: ' + err);
      } else if (config.platform === 'darwin') {
        exec('dsymutil -o ' + path.resolve(config.dirOutput, config.project.outputExecutableName) + '.dSYM ' + path.resolve(config.dirOutput, config.project.outputExecutableName), function(err, stdout, stderr) {
          if (err) {
            return console.error(err);
          }
        });
      }
      return done();
    });
  };

  Launch = function(done) {
    var app;
    app = spawn(path.resolve(config.dirOutput, config.project.outputExecutableName), [], {
      stdio: 'inherit'
    });
    return app.on('close', function(code) {
      console.log('child process exited with code ' + code);
      return done();
    });
  };

  Prebuild = gulp.parallel(Mustache, CSON, Assets);

  Rebuild = gulp.series(Clean, Prebuild, CompileAll);

  gulp.task('config', Configure);

  gulp.task('watch', watcher);

  gulp.task('rebuild', Rebuild);

  gulp.task('link', Link);

  gulp.task('build', gulp.series(CompileAll, Link));

  gulp.task('launch', Launch);

  gulp.task('default', gulp.series(Configure, Start));

}).call(this);
