// Generated by CoffeeScript 1.12.7
(function() {
  var child_process, config, fs, glob, gulp, gutil, libclang, mustache, os, path, rename;

  config = new (require('./config.js'))();

  require('shelljs/global');

  os = require('os');

  fs = require('fs');

  path = require('path');

  child_process = require('child_process');

  glob = require('glob');

  libclang = require('libclang');

  gulp = require('gulp');

  gutil = require('gulp-util');

  mustache = require("gulp-mustache");

  rename = require("gulp-rename");

  module.exports = function() {
    var AngelScriptBindingParams, CreateTask_bindings, WriteAngelScriptConstants, bindingHeader, bindingSource, convertClangType, convertClangTypedefType, params;
    convertClangType = function(str) {
      str = str.replace(/Uint32|GLenum/g, "uint32_t");
      str = str.replace(/Uint64/g, "uint64_t");
      str = str.replace(/Bool/g, "bool");
      str = str.replace(/Void/g, "void");
      str = str.replace(/Int|Long/g, "int32_t");
      str = str.replace(/UInt|ULong/g, "uint32_t");
      return str;
    };
    convertClangTypedefType = function(type) {
      var pointerType;
      switch (type.canonical.spelling) {
        case 'Void':
          return 'void';
        case 'Bool':
          return 'bool';
        case 'Char_U':
        case 'UChar':
          return 'uint8';
        case 'Char_S':
        case 'SChar':
          return 'int8';
        case 'UShort':
          return 'uint16';
        case 'Short':
          return 'int16';
        case 'UInt':
        case 'ULong':
          return 'uint32';
        case 'Int':
        case 'Long':
          return 'int32';
        case 'ULongLong':
          return 'uint64';
        case 'LongLong':
          return 'int64';
        case 'Float':
          return 'float';
        case 'Double':
          return 'double';
        case 'Pointer':
          pointerType = type.pointeeType.declaration.spelling;
          if (pointerType.length === 0) {
            pointerType = 'void';
          }
          return pointerType;
        default:
          return null;
      }
    };
    AngelScriptBindingParams = (function() {
      function AngelScriptBindingParams() {}

      AngelScriptBindingParams.prototype.sourceFile = null;

      AngelScriptBindingParams.prototype.outputFilename = null;

      AngelScriptBindingParams.prototype.includes = [];

      AngelScriptBindingParams.prototype.footerLines = [];

      AngelScriptBindingParams.prototype.includeCursorRegex = "";

      AngelScriptBindingParams.prototype.excludeCursorRegex = "";

      AngelScriptBindingParams.prototype.clangParams = [];

      return AngelScriptBindingParams;

    })();
    params = new AngelScriptBindingParams;
    params.sourceFile = path.resolve(config.dirLibrary, config.platform, 'include', 'GL', 'glew.h');
    params.includeCursorRegex = /(\bGL|\bgl[A-Z])/;
    params.excludeCursorRegex = /@|_ARB\b|_NV\b|_ATI\b|_SGIS\b|_EXT\b|GLU|glu|GLvoid|GLsync|GLenum/;
    params.clangParams = ['-x', 'c++'];
    params.includes = ['GL/glew.h'];
    bindingHeader = {
      taskname: 'binding-header',
      templatefilename: 'Binding.h.mustache',
      outfilename: 'Binding.h',
      context: {
        Declarations: []
      }
    };
    bindingSource = {
      taskname: 'binding-source',
      templatefilename: 'Binding.cpp.mustache',
      outfilename: 'Binding.cpp',
      context: {
        Declarations: []
      }
    };
    WriteAngelScriptConstants = function(params, generatedName) {
      var rs, stringBuffer, ws;
      rs = fs.createReadStream(params.sourceFile, {
        flags: 'r',
        encoding: 'utf8'
      });
      ws = fs.createWriteStream(path.resolve(config.dirAsset, 'script', generatedName + '.as'));
      ws.on('error', function(err) {
        return console.log('error: ' + err);
      });
      stringBuffer = '';
      rs.on('error', function(err) {
        return console.log('error: ' + err);
      });
      rs.on('data', function(chunk) {
        return stringBuffer += chunk;
      });
      return rs.on('end', function() {
        var i, identifier, j, kvarray, len, len1, m, obj, re, splits, uniqBy, uniqueArray, value;
        re = new RegExp(/^#define\s+(\w+)\W+((0x)?\d+)$/gm);
        splits = stringBuffer.match(re);
        kvarray = [];
        for (i = 0, len = splits.length; i < len; i++) {
          m = splits[i];
          identifier = m.replace(re, '$1');
          value = m.replace(re, '$2');
          kvarray.push({
            token: identifier,
            value: value
          });
        }
        uniqBy = function(a, key) {
          var seen;
          seen = {};
          return a.filter(function(item) {
            var k;
            k = key(item);
            if (seen.hasOwnProperty(k)) {
              return false;
            } else {
              seen[k] = true;
              return true;
            }
          });
        };
        uniqueArray = uniqBy(kvarray, function(item) {
          return item['token'];
        });
        for (j = 0, len1 = uniqueArray.length; j < len1; j++) {
          obj = uniqueArray[j];
          ws.write('const uint32 ' + obj.token + ' = ' + obj.value + ';\n');
        }
        return ws.end();
      });
    };
    CreateTask_bindings = function(taskname, params) {
      var generatedName, outputFilename;
      generatedName = path.basename(params.sourceFile).replace(/\./, '_');
      outputFilename = path.resolve(config.dirSource, 'Binding-' + generatedName + '.cpp');
      params.context.Declarations.push({
        name: generatedName
      });
      return gulp.task(taskname, function(cb) {
        var Cursor, Index, TranslationUnit, functionDef, i, index, len, line, ref, tu, ws;
        WriteAngelScriptConstants(params, generatedName);
        ws = fs.createWriteStream(outputFilename);
        ws.write('// THIS FILE IS GENERATED\n');
        ws.write('#include "Binding.h"\n');
        ref = params.includes;
        for (i = 0, len = ref.length; i < len; i++) {
          line = ref[i];
          ws.write(['#include "', line, '"\n'].join(''));
        }
        ws.write(['void RegisterBindings_', generatedName, '( asIScriptEngine* engine )', '\n', '{', '\n', 'int r = 0;', '\n'].join(''));
        Cursor = libclang.Cursor;
        Index = libclang.Index;
        TranslationUnit = libclang.TranslationUnit;
        index = new Index(true, true);
        tu = new TranslationUnit.fromSource(index, params.sourceFile, params.clangParams);
        functionDef = null;
        tu.cursor.visitChildren(function(parent) {
          var actualType, commentStr, modifiedFunc;
          if (params.includeCursorRegex.test(this.spelling) === true && params.excludeCursorRegex.test(this.spelling) === false) {
            switch (this.kind) {
              case Cursor.LastProcessing:
                return Cursor.Break;
                break;
              case Cursor.FunctionDecl:
                if (functionDef !== null) {
                  ws.write(functionDef.join(' '));
                  functionDef = null;
                }
                modifiedFunc = this.displayname.replace(/\*/g, "@");
                modifiedFunc = convertClangType(modifiedFunc);
                if (params.includeCursorRegex.test(modifiedFunc) === true && params.excludeCursorRegex.test(modifiedFunc) === false) {
                  commentStr = '';
                } else {
                  commentStr = '//';
                }
                functionDef = [commentStr, 'r = engine->RegisterGlobalFunction( "', convertClangTypedefType(this.type.canonical.result), modifiedFunc, '", asFUNCTION(', this.canonical.spelling, '), asCALL_CDECL ); SDL_assert( r>=0 );\n'];
                return Cursor.Recurse;
                break;
              case Cursor.TypedefDecl:
                actualType = convertClangTypedefType(this.typedefType);
                if (actualType !== null && actualType !== 'void') {
                  ws.write('r = engine->RegisterTypedef( "' + this.spelling + '", "' + actualType + '" ); SDL_assert( r>=0 );\n');
                }
                return Cursor.Continue;
                break;
              case Cursor.ClassDecl:
                console.log('CLASS', this.spelling, this.kind.spelling, this.type.spelling);
                ws.write('r = engine->RegisterObjectType("' + this.spelling + '", sizeof(' + this.spelling + '), asOBJ_VALUE | asOBJ_POD); SDL_assert( r >= 0 );\n');
                return Cursor.Recurse;
                break;
              case Cursor.FieldDecl:
                console.log('FIELD', this.spelling, this.kind.spelling, this.type.spelling);
                return Cursor.Continue;
                break;
              case Cursor.StructDecl:
                console.log('STRUCT', this.spelling, this.kind.spelling, this.type.spelling);
                ws.write('r = engine->RegisterObjectType("' + this.spelling + '", sizeof(' + this.spelling + '), asOBJ_VALUE | asOBJ_POD); SDL_assert( r >= 0 );\n');
                return Cursor.Recurse;
                break;
              case Cursor.Record:
                console.log('RECORD', this.spelling, this.kind.spelling, this.type.spelling);
                return Cursor.Recurse;
                break;
              case Cursor.MacroDefinition:
                return Cursor.Recurse;
                break;
              case Cursor.MacroInstantiation:
                return Cursor.Continue;
                break;
              case Cursor.IntegerLiteral:
                console.log('IntegerLiteral!!!');
                return Cursor.Continue;
                break;
            }
          }
          return Cursor.Recurse;
        });
        ws.write('}\n');
        ws.end();
        return cb();
      });
    };
    CreateTask_mustache(bindingHeader);
    CreateTask_mustache(bindingSource);
    CreateTask_bindings('binding-glew', params);
    return gulp.task('bindings', function() {
      gulp.start('binding-source');
      return gulp.start('binding-header');
    });
  };

}).call(this);
